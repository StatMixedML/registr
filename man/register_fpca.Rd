% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/register_fpca.R
\name{register_fpca}
\alias{register_fpca}
\title{Register curves from exponential family using constrained optimization and generalized FPCA}
\usage{
register_fpca(Y, Kt = NULL, Kh, family = "binomial", iterations = 10,
  first.step = "registration", npc = 1, gradient = TRUE, ...)
}
\arguments{
\item{Y}{dataframe. Should have values id, value, index.}

\item{Kt}{number of B-spline basis functions used to estimate mean functions. 
Defaults to (N^1/5 + 4).}

\item{Kh}{number of B-spline basis functions used to estimate warping functions \emph{h}. Defaults to 5.}

\item{family}{\code{gaussian} or \code{binomial}.}

\item{iterations}{number of iterations between fpca step and registration step.}

\item{first.step}{\code{registration} or \code{fpca}. If \code{registration} we initialize values with the population mean.}

\item{npc}{defaults to 1. Number of principal components to calculate.}

\item{gradient}{if TRUE, uses analytic gradient to calculate derivative.}

\item{...}{additional arguments passed to registration and fpca functions}
}
\value{
fpca_obj list of items from FPCA step

reg_object some registration stuff, should be cleaned up

time_warps list of time values for each iteration of the algorithm. time_warps[1] returns original (observed) time 
and time_warps[n] provides time values for the final iteration

loss Loss for each iteration of the algorithm. Loss is calculated in the registration step using an 
exponential family likelihood with natural parameter calculated in the FPCA step.

family \code{gaussian} or \code{binomial}.
}
\description{
Function combines constrained optimization and FPCA to estimate warping functions for exponential family data.
}
\examples{

\dontrun{
library(tidyverse)

library(gridExtra)
library(refund.shiny)

library(mvtnorm)
library(splines)
library(boot)

## design elements for simulated data
I = 50                            ## number of subjects
D = 100                           ## size of grid for observations
tstar = seq(0, 1, length = D)     ## shared time grid across subjects
Kt = 10                           ## dimension of bspline basis for mean and fpc functions
Kt_h = 5                          ## dimension of spline basis for warping functions
lambda.true = c(20)               ## variance of fpca scores

## functions to create mean and fpca functions on specified grid
mean.curve = function(grid) {
  3*(0 - sin(2*grid*pi) - cos(2*grid*pi) )
}
amp.curve = function(grid) {
  (0 - sin(2*grid*pi) - cos(2*grid*pi) )  / sqrt(322)
}

## function to create subject-specific time grid
grid.subj.create = function(coefs) {
  BS = bs(1:D, df = 3, intercept = FALSE, degree = 3)
  coefs = cumsum(coefs) / sum(coefs)
  (BS \%*\% coefs)
}


###############################################################
## registration for binary curves using logistic models for
## fpca and registration
###############################################################

## generate features for curves
c.true = rmvnorm(I, mean = rep(0, 1), sigma = diag(lambda.true, 1, 1))

## generate curves
Yi.obs = Yi.latent = pi.true = t.subj = matrix(NA, I, D)
Yi.regis.true = matrix(NA, I, D)
for (i in 1:I) {
  t.subj[i,] = runif(3, 0, 1) \%>\% grid.subj.create \%>\% as.vector
  Yi.latent[i,] = mean.curve(grid = t.subj[i,]) + c.true[i] * amp.curve(grid = t.subj[i,])
  pi.true[i,] = inv.logit(Yi.latent[i,])
  Yi.regis.true[i,] = mean.curve(grid = tstar) + c.true[i] * amp.curve(grid = tstar)
  for (j in 1:D) {
    Yi.obs[i,j] = rbinom(1, 1, pi.true[i,j])
  }
}

 Y_sim = as_refundObj(Yi.obs)
 reg_sim = register_fpca(Y_sim, Kt = 8, Kh = 4, family = "binomial", iterations = 10, npc = 1,
     first.step = "registration")

 plot_binary(reg_sim$reg_object, tstar = Y_sim$index)


}

}
\author{
Julia Wrobel \email{jw3134@cumc.columbia.edu}
}
