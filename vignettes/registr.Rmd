---
title: "registr: a vignette"
author: "Julia Wrobel"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
references:
- id: tipping1999
  title: Probabilistic Visualisation of High-dimensional binary data
  author:
  - family: Tipping
    given: M.E.
  container-title: Advances in neural information processing systems
  page: 592-598
  type: article-journal
  issued:
    year: 1999
vignette: >
  %\VignetteIndexEntry{registr: a vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE
)
```

The `registr` package is for registering, or aligning, exponential family functional data. Right now it works for binary or continuous data.

```{r load_libraries, echo = FALSE}
library(registr)
library(boot)
library(ggplot2)
library(dplyr)
```


## 'registr package'

The main function in the package is `register_fpca()`. It calls a registration function, `registr()`, performs curve alignment and an gfpca function which calculates a template to which curves are registered using generalized functional principal component analysis (gfpca). The function that calculates gfpca depends on the family. For `family = "binomial"` the `bfpca()` function performs this step and for `family = "gaussian"` the `fpca_gauss()` function performs this step. The `register_fpca()` function iterates between the alignment and template calculation steps until curves are registered. 

This vignette provides examples that highlight the functionality of the package. 	

### A note on data formatting

Use of this package requires that data be in a specific format: a long-form data frame with variables `id`, `index`, and `value`, where the `value` column contains functional observations for all subjects, the `id` column identifies which observations belong to which subject, and `index` provides the grid (domain) over which the `value`s are observed.  

The variable `id` should be a unique identifier in that each id identifies a single subject. Since we assume there is only one curve per subject for this package, `id` uniquely identifies each curve as well. Other covariates can be included in the data as long as the variables `id`, `index`, and `value` are present.

## Simulated data

There are two functions for simulating data included in the package: `simulate_functional_data()` and `simulate_unregistered_curves()`. Both functions simulate functional data; the first is intended for testing the gfpca functions in our package and the second is for demonstrating our registration algorithm.

### Simulate data for registration

The second function for simulating data, `simulate_unregistered_curves()`, generates curves intended to mimic accelerometer data. Use it to test out the `registr()` and `register_fpca()` functions.

Below I generate data using this function:

```{r sim_data2}
registration_data = simulate_unregistered_curves(I = 50, D = 200, seed = 2018)

head(registration_data)

```

I simulated data with $I = 10$ subjects and $D = 200$ time points per subject. The resulting object,`registration_data`, is a data frame with variables `id`, `value`, `index`, `latent_mean`, and `t`. Variables `id`, `value`, and `latent_mean` are the same as those from the `fpca_object` data. The variables `index` and `t` are both time grids. Evaluated on the grid `index` the data is unregistered, and on the grid `t` the data is registered. Registered and unregistered curves are plotted below.

```{r plot_sim2, echo = FALSE, fig.show='hold'}

registration_data %>%
	ggplot(aes(index, inv.logit(latent_mean), group = id)) + theme_bw() + 
	geom_line(alpha = 0.25) + labs(y = "Pr(Y = 1)")

registration_data %>%
	ggplot(aes(t, inv.logit(latent_mean), group = id)) + theme_bw() + 
	geom_line(alpha = 0.25) + labs(y = "Pr(Y = 1)")

```

Each curve has one main peak, but the location of that peak is shifted. When curves are registered the peaks are aligned.

### Simulate data for gfpca

`simulate_functional_data()` simulates data with a population-level mean and two orthogonal principal components based on sine and cosine functions. Below I generate data using this function:

```{r sim_data1}
fpca_data = simulate_functional_data(I = 100, D = 200)

ls(fpca_data)

head(fpca_data$Y)
```

I simulated data with $I = 100$ subjects and $D = 200$ time points per subject. The resulting object,`fpca_data`, is a list that contains the true population-level mean (`alpha`) and principal components (`psi1` and `psi2`), and a dataframe (`Y`). The dataframe `Y` contains variables `id`, `value`, `index` and `latent_mean`, which is consistent with the format our `registr` software requires. `id` indicates data for a particular subject, `index` is the time grid for that subject, evaluated on $[0,1]$, the `value` variable contains binary observations, and `latent_mean` contains continuous observations used to generate the binary observations for the `value` variable. Note that when `family = "binomial"` we will use the binary `value` variable as the observations for each subject and when `family = "gaussian"` we use the `latent_mean` variable as the outcome. This data is plotted below.

```{r plot1_sim1, fig.show='hold', fig.width = 2, echo = FALSE}

Y = fpca_data$Y
pc_df = data.frame(pop_mean = fpca_data$alpha, 
									 psi1 = fpca_data$psi1,
									 psi2 = fpca_data$psi2,
									 index = seq(0, 1, length.out = 200),
									 id = 1)

ggplot(Y, aes(index, latent_mean, group = id)) + theme_bw() +
	geom_line(alpha = 0.25) + geom_line(data = pc_df, aes(y = pop_mean), color = "red") 

ggplot(pc_df, aes(index, psi1)) + theme_bw() + geom_line(color = "blue") 
ggplot(pc_df, aes(index, psi2)) + theme_bw() + geom_line(color = "blue") 

```

The left panel of the figure above shows the latent means for each subject, along with the population-level mean,  $\alpha(t)$, in red. The middle and right panels show the first and second principal components, $\psi_1(t)$ and $\psi_2(t)$, respectively. Using the $logit^{-1}(\cdot)$ function we can convert the subject-specific means to probabilities; these probabilities are used to generate the binary values. Binary values and latent probability curve for one subject in the dataset is shown below.

```{r plot2_sim1, echo = FALSE}
Y %>%
	filter(id == 7) %>%
	ggplot(aes(index, value)) + theme_bw() +
	geom_point(alpha = 0.75, size = 0.25) + geom_line(aes(y = inv.logit(latent_mean))) +
	labs(y = "Pr(Y = 1)")

```

We can alter the score variance for the principal components using the arguments `lambda1` and `lambda2`. The default setting is for all subjects to have the same number of time points. However, by specifying `vary_D = TRUE`, we can generate data with uneven grid lengths for each subject.

## Registration using `register_fpca()`

`register_fpca()` is the main function for the `registr` package. The algorithm implemented by this function is described in our [paper](). Use the `family` argument to this function to specify what type of exponential family data you would like to align. Right now our package supports `family = "binomial"` for registering binary data and `family = "gaussian"` for registering continuous data.

### `register_fpca(family = "binomial")` for binary data

To register binary data use the following code:

```{r register_binary, message = FALSE}

registr_bin = register_fpca(Y = registration_data, family = "binomial", Kt = 8, Kh = 3, npc  = 1)
```

The argument `Y` specificies the input dataset; here we use the simulated `registration_data`. `Kt` and `Kh` specify number of B-spline basis functions for the subject-specific means and warping functions, respectively, and `npc` indicates the number of functional principal components to use.

```{r plot_reg_bin, echo = FALSE, fig.show='hold', fig.width=2}
Y = registr_bin$Y

ggplot(Y, aes(tstar, inv.logit(latent_mean), group = id)) + theme_bw() + 
	geom_line(alpha = 0.25) + labs(y = "Pr(Y = 1)")

ggplot(Y, aes(t, inv.logit(latent_mean), group = id)) + theme_bw() + 
	geom_line(alpha = 0.25) + labs(y = "Pr(Y = 1)")

ggplot(Y, aes(t_hat, inv.logit(latent_mean), group = id)) + theme_bw() + 
	geom_line(alpha = 0.25) + labs(y = "Pr(Y = 1)")

```

Plotted above are results of registering the binary data.At left probabilities on unregistered domain $t^*$, center are probabilities on true registered domain $t$, and at right are probabilities on estimated registered domain $\hat{t}$. After registration the underlying probabilities are aligned- though it is important to note that we register based on the underlying binary observations, not the true probabilities.

```{r plot_reg_bin_warp, echo = FALSE, fig.show='hold'}

ggplot(Y, aes(tstar, t, group = id)) + theme_bw() + 
	geom_line(alpha = 0.25)

ggplot(Y, aes(tstar, t_hat, group = id)) + theme_bw() + 
	geom_line(alpha = 0.25)


```

The true an estimated warping functions are plotted above. 

### continuous data

Not yet implemented- I have code from Jihui but need to clean it up.

## `bfpca()` function

The functional principal components analysis we implement for binary data (bfpca) is a novel variational EM algorithm derived from methods for binary probabilistic PCA [@tipping1999].

Our `bfpca()` functions works for data that is sparse and irregular (subjects do not have to be observed on the same grid and do not have to have the same number of grid points). The following code runs bfpca on  the `fpca_data` dataset.

```{r bfpca}
bfpca_object = bfpca(fpca_data$Y, npc = 2, Kt = 8, print.iter = TRUE)

```

Here we use the argument `print.iter = TRUE` to print the error after each iteration. Plotted below are the true and estimated population-level mean and FPCs:

```{r plot_bfpca, echo = FALSE, fig.show='hold', fig.width=2}
pc_df = pc_df %>%
	mutate(psi1_est = bfpca_object$efunctions[,1],
	psi2_est = bfpca_object$efunctions[,2],
	alpha_est = bfpca_object$alpha)

ggplot(pc_df, aes(index, pop_mean)) + theme_bw() + geom_line(color = "blue") +
	geom_line(aes(y = alpha_est), linetype = 2, color = "red")

ggplot(pc_df, aes(index, psi1)) + theme_bw() + geom_line(color = "blue") +
	geom_line(aes(y = psi2_est), linetype = 2, color = "red")

ggplot(pc_df, aes(index, psi2)) + theme_bw() + geom_line(color = "blue") +
	geom_line(aes(y = psi1_est), linetype = 2, color = "red")

```

Our algorithm runs quickly and does a good job recovering the true FPCs. Note that while the truth and estimation are not perfectly aligned, this is to be expected - the data used to estimate these functions are binary observations that are generated for the truth with some variability, so results are not expected to perfectly align. One would expect results to get better with increasing number of time points per subject.

## `registr()` function

The registration step of `register_fpca()` calls the `registr` function. Though registration is intended to be performed through the `register_fpca()` function `registr()` can work as a standalone function. `registr()` uses constrained maximization of an exponential family likelihood function to estimate functions that align curves.

The default option `gradient = TRUE` implements an analytic gradient for this optimization problem. Selecting `gradient = FALSE` implements a numeric gradient which is less computationally efficient. This is illustrated in the code below. 

```{r registr_function}
data_test_gradient = simulate_unregistered_curves(I = 50, D = 100)

start_time = Sys.time()
reg_analytic = registr(Y = data_test_gradient, family = "binomial", gradient = TRUE)
end_time = Sys.time()

analytic_gradient = as.numeric(round((end_time - start_time), 2))

start_time = Sys.time()
reg_numeric = registr(Y = data_test_gradient, family = "binomial", gradient = FALSE)
end_time = Sys.time()

numeric_gradient = as.numeric(round((end_time - start_time), 2))

```

On a dataset with just 50 subjects and 100 time points per subject, the `registr()` function runs in `r analytic_gradient` seconds with an analytic gradient and `r numeric_gradient` seconds with a numeric gradient. Since the `register_fpca()` algorithm is iterative and calls the `registr()` function several times, using an analytic derivative drastically increases the computational efficiency, especially if number of subjects in the dataset is large.

## Help files

Documentation for individual functions gives more information on their arguments and return objects, and can be pulled up via the following:

- `?registr`
- `?bfpca`
- `?register_fpca`

## References
